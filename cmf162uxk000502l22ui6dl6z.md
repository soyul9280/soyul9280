---
title: "[Spring] N+1문제"
datePublished: Tue Jul 01 2025 15:00:00 GMT+0000 (Coordinated Universal Time)
cuid: cmf162uxk000502l22ui6dl6z
slug: spring-n1
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1756727965704/8c24d83c-1a9e-4b4d-b733-c130243cbc6b.png
tags: jpa, n1

---

## ✍️ 작성하게 된 이유

옷을 관리하는 서비스를 개발하면서 `Cloth` 엔티티와 그에 연관된 `ClothWithAttributes`, `Attribute` 데이터를 함께 조회하는 기능이 필요했다.  
그런데 연관 데이터를 조회할 때마다 **쿼리가 폭발적으로 증가(N+1 문제)** 하며, **성능이 급격히 저하**되는 상황을 마주하게 되었다.

이번 글에서는 실제로 겪은 **N+1 문제 발생 배경**, **해결 방법(EntityGraph)**, K6를 이용한 **성능비교**를 정리했다.

---

## N+1 문제란?

JPA에서 연관관계를 가진 엔티티를 조회할 때,**조회된 데이터 갯수만큼(n)** 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오게 된다. 이를 N+1문제라고 한다.

## 상황

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1756729566307/ee8dffdb-6ea1-4148-ab58-ee49e77889b6.png align="center")

* 현재 연관관계 상태이다.
    
* 속성 정의는 2개로 `test`, `계절`이 저장된 상태이다
    
* 위와 같은 구조에서 옷(Cloth)을 2개를 등록한 후 조회를 시도했다.
    
* 옷 → clothes\_attribute → 속성 정의
    
* 테이블
    
    * `clothes` 테이블:옷 정보 등록
        
    * `users`테이블: 사용자 정보 등록
        
    * `clothes_attribute_def` 테이블: 의상 속성 정의 테이블( 속성이름, 선택 후보값 )
        
    * `clothes_attribute` 테이블: 의상 속성 테이블(의상, 속성, 사용자가 선택한 속성 선택값)
        

## 🧪 결과 (N+1 문제 발생)

### 배포 서버 | K6

1. #### 최대 사용자 약 100명(78req/s)
    
2. #### 최대 요청 수 84req/s.
    

상황 : 사용자 6명, 옷 100개, 속성 4개

가정1 : 2분 동안 100명씩 최대 500명까지 단계적 증가 ( Google Workspace Business Plus = 500명 참여 화상회의 지원 내용 참고 )

테스트1 : 의상 조회 API, 동시 접속자가 몇 명까지 버틸 수 있는가

기준1 : 지연시간 1s ( 1s이상 걸린다면 사용자 이탈률 증가하기 때문)

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1758541956916/4621fcfa-2b53-4818-8762-13e0c9c9f9bd.png align="center")

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1758542318169/1521bd0a-bd63-4afc-9694-31c5b29487f5.png align="center")

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1758542333163/3ac7b1dd-cfdb-4bfc-990b-e5d409f435e5.png align="center")

결과 해석

22:19 지연시간 1초 도달, 해당 구간 가상 유저 수 106명, 최대 요청 수 78.1req/s

→ 응답 지연 발생, RDS 병목 현상 발생

→ 최대 사용자 수 약 100명

가정2: 2분동안 100개씩 요청 수 증가, 최대 400개까지 단계적 증가

테스트2 : 의상 조회 API, 가상 유저수가 100까지 늘어날 때 한 유저가 요청할 수 있는 최대 수

기준2 : 지연시간 1s ( 1s이상 걸린다면 사용자 이탈률 증가하기 때문)

안전성 확보 : 시작을 0으로 두면 요청이 갑자기 몰리면서 콜드 스타트 지연 가능성 존재 → 50으로 웜업 → 정상 처리 상태 확인 후 점진적 증가

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1758543464580/699d2e09-c054-4a02-9646-2b028a041e16.png align="center")

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1758543483858/b1bfe5df-88c0-4e58-8069-78b58396039c.png align="center")

결과 해석

22:35부터 시점 1초 이상 튀는 구간 발생 → 병목 시작 시점, 동시 사용자 94명, 84.6req/s

→ 사용자 늘었지만 서버 못 따라감 = 응답 지연 발생, RDS 병목 현상 발생

→ 최대 요청 수 : 약 84개

### 로컬 서버 | 총 쿼리 수 **9개, 169m/s**

옷 2개를 위한 조회 1번(의상 타입이 검색 조건이다)

* 어떤 속성을 선택했는지 보여주기 위해 각 옷에 대한 속성 조회 2번
    
* 속성은 어떤 후보 값들을 가지고 있는지 보여주기 위해 각 속성의 속성정의 조회 4번
    
* 기타: 유저 조회 1번, 조회 페이징 카운트 쿼리 1번
    

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1756730369003/573510f1-ac5e-4d51-a7b4-fee7b1afff6c.png align="center")

## 왜 이런 일이 벌어질까?

#### **지연로딩(LAZY)**

* JPA의 연관관계는 기본적으로 **지연로딩(LAZY)** 으로 설정함.
    
* 즉, 연관된 엔티티는 실제로 **접근하는 순간에 쿼리를 실행.**
    
* `@ManyToOne(fetch = LAZY)` 관계에서 루프 내에서 .getXXX() 같은 코드가 실행되면,  
    그 때마다 DB에서 select 발생 → 이게 N번
    

## 단기 해결방법

`FetchJoin`

JPA의 JPQL에서 **연관 엔티티를 명시적으로 JOIN**하여 **한 번의 쿼리로 함께 조회**하는 방법이다.

JPQL에서 성능 최적화를 위해 제공하는 기능이다.

JOIN과 달리, 연관 엔티티를 **즉시 로딩**해서 실제 객체로 채워준다.

**기본적으로는 inner join으로 동작**하고 left join이라고 명시하면 outer join이 된다.

| 항목 | 설명 |
| --- | --- |
| 동작 방식 | SQL의 JOIN처럼 동작하며 Article과 Member를 **한 번에 조회**, 영속성 컨텍스트 1차 캐시에 저장되어 바로 활용될 수 있음 |
| 대상 | `@ManyToOne, @OneToMany` 모두 가능 |
| 장점 | N+1 완전 차단, 쿼리 한 번에 모든 데이터 조회 |
| 단점 | 컬렉션에서 페이징 불가, 복잡한 조인 시 중복 문제 발생, LAZY 설정 사용 불가능, 이중 컬렉션 페치 불가 |

`@EntityGraph`

Spring Data JPA에서 연관 엔티티를 fetch join처럼 미리 불러오도록 지시(EAGER로 동작)하는 선언적 방법이다. **left outer join이 사용되며** 페이징과 함께 사용 가능하다

| 항목 | 설명 |
| --- | --- |
| 동작 방식 | 내부적으로 **join fetch를 자동 생성** |
| 대상 | `@ManyToOne`, `@OneToMany` |
| 장점 | 페이징(Pageable) 가능, 코드 간결, 단건 + 컬렉션 가능 |
| 단점 | 복잡한 조인에는 한계, **JPQL처럼 유연한 제어 어려움** |

`@BatchSize`

* **지연 로딩이 발생할 때** ID를 모아 **IN 쿼리로 한 번에 조회 (추가 쿼리 1개)**
    
* 전역 설정도 가능
    

Fetch Join을 이용해보려했으나 이중 페치 조인은 불가하고 속성의 모든 정의를 불러와야하니 `@EntityGrpah`를 사용하였다.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1756731638737/93b2782a-8dea-4d45-ac0b-a1308b71053b.png align="center")

* `Cloth` → `ClothWithAttributes` → `Attribute`까지 한번에 조회
    

## 결과 (`@EntityGraph`적용 후)

### 배포 서버 | K6

1. #### 최대 사용자 약 200명(197req/s)
    
2. #### 최대 요청 수 100req/s.
    

테스트 1 결과

20:13 즈음부터 최대 요청 수 병목 발생 : 약 200명(197req/s), 지연시간 1s 이내 , RDS 병목 현상 발생

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1758544273295/e3d6d9ad-3122-413b-8f56-98706b0c59cd.png align="center")

테스트 2 결과

20:00:30 즈음부터 최대 요청 수 100req/s 병목 발생, 지연시간 1s이내, RDS병목 현상 발생

N+1해결 전 요청 수가 가상 유저 수 증가를 따라가지 못하는 응답 지연이 생겼었지만 현 시점 해결

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1758544502966/0027f694-73c9-4293-9bcc-e975682e5f20.png align="center")

## 로컬 서버 | 총 쿼리 수 **6개, 34m/s**

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1756731031931/72ff1e6b-047f-4bf2-bbf9-a85d6b3a83e7.png align="center")

## ✅ 성능 개선 수치

| 구분 | 최대 사용자 수 | 최대 요청 수 | 쿼리 수 | 조회 시간 |
| --- | --- | --- | --- | --- |
| 기존(N+1 문제 발생) | **100명** | **84req/s** | **9개** | **169ms** |
| EntityGraph 적용 | **200명** | **100req/s** | **6개** | **34ms** |

* **최대 사용자 수 : 2배 개선, 100% 증가**
    
* **최대 요청 수 : 1.2배 개선, 약 19% 증가**
    
* **쿼리 수 : 약 1.5배 개선, 33% 감소**
    
* **조회 시간 : 약 5배, 80%개선**
    
* 같은 데이터를 조회하면서도, **필요한 연관 관계를 미리 가져와 성능 최적화**
    

## 회고

하지만, RDS 병목을 해결하지 못했다. `@EntityGraph`는 카디널리티 곱으로 조인이 되어 중복 데이터가 발생할 수 있다.

이 문제로 RDS에서 병목이 생긴 것으로 확인된다. 이를 해결하기 위한 **장기적인 방법**으로 2가지가 있다.

1. 필요한 데이터만 갖고 직접 쿼리 작성
    
2. 데이터 구조 변경
    

이력서 작성과 스터디가 마무리되면 리팩토링을 진행해봐야겠다.

## 참고자료

[**N+1 문제 | Incheol's TECH BLOG**](https://incheol-jung.gitbook.io/docs/q-and-a/spring/n+1)​

[개발 N년차**JPA N+1 문제 해결 방법 및 실무 적용 팁 - 삽질중인 개발자**](https://programmer93.tistory.com/83#google_vignette)​

[평양냉면7**JPA N+1 문제 해결하기 (fetch join, entityGraph, batch size)**](https://yijoon009.tistory.com/entry/JPA-N1-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0-fetch-join-entityGraph-batch-size)

[뱅어돔**JPA N+1 문제에 대하여 (BatchSize, EntityGraph)**](https://toquasimodox.tistory.com/8)​​

[https://tudamoa.tistory.com/13](https://tudamoa.tistory.com/13)