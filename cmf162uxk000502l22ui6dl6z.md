---
title: "[Spring] N+1문제"
datePublished: Tue Jul 01 2025 15:00:00 GMT+0000 (Coordinated Universal Time)
cuid: cmf162uxk000502l22ui6dl6z
slug: spring-n1
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1756727965704/8c24d83c-1a9e-4b4d-b733-c130243cbc6b.png
tags: jpa, n1

---

## ✍️ 작성하게 된 이유

옷을 관리하는 서비스를 개발하면서 `Cloth` 엔티티와 그에 연관된 `ClothWithAttributes`, `Attribute` 데이터를 함께 조회하는 기능이 필요했다.  
그런데 연관 데이터를 조회할 때마다 **쿼리가 폭발적으로 증가(N+1 문제)** 하며, **성능이 급격히 저하**되는 상황을 마주하게 되었다.

이번 글에서는 실제로 겪은 **N+1 문제 발생 배경**, **해결 방법(EntityGraph)**, 그리고 **쿼리 수 개선 전후 비교**를 정리했다.

---

## N+1 문제란?

JPA에서 연관관계를 가진 엔티티를 조회할 때,**조회된 데이터 갯수만큼(n)** 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오게 된다. 이를 N+1문제라고 한다.

## 상황

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1756729566307/ee8dffdb-6ea1-4148-ab58-ee49e77889b6.png align="center")

* 현재 연관관계 상태이다.
    
* 속성 정의는 2개로 `test`, `계절`이 저장된 상태이다
    
* 위와 같은 구조에서 옷(Cloth)을 2개를 등록한 후 조회를 시도했다.
    
* 테이블
    
    * `clothes` 테이블:옷 정보 등록
        
    * `users`테이블: 사용자 정보 등록
        
    * `clothes_attribute_def` 테이블: 의상 속성 정의 테이블( 속성이름, 선택 후보값 )
        
    * `clothes_attribute` 테이블: 의상 속성 테이블(의상, 속성, 사용자가 선택한 속성 선택값)
        

## 🧪 결과 (N+1 문제 발생) : 총 쿼리 수 **9개, 169m/s**

. 옷 2개를 위한 조회 1번(의상 타입이 검색 조건이다)

* 어떤 속성을 선택했는지 보여주기 위해 각 옷에 대한 속성 조회 2번
    
* 속성은 어떤 후보 값들을 가지고 있는지 보여주기 위해 각 속성의 속성정의 조회 4번
    
* 기타: 유저 조회 1번, 조회 페이징 카운트 쿼리 1번
    

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1756730369003/573510f1-ac5e-4d51-a7b4-fee7b1afff6c.png align="center")

## 왜 이런 일이 벌어질까?

#### **지연로딩(LAZY)**

* JPA의 연관관계는 기본적으로 **지연로딩(LAZY)** 으로 설정함.
    
* 즉, 연관된 엔티티는 실제로 **접근하는 순간에 쿼리를 실행.**
    
* @ManyToOne(fetch = LAZY) 관계에서 루프 내에서 .getXXX() 같은 코드가 실행되면,  
    그 때마다 DB에서 select 발생 → 이게 N번
    

## 해결방법

1. FetchJoin
    
    JPA의 JPQL에서 **연관 엔티티를 명시적으로 JOIN**하여 **한 번의 쿼리로 함께 조회**하는 방법이다.
    
    JPQL에서 성능 최적화를 위해 제공하는 기능이다.
    
    JOIN과 달리, 연관 엔티티를 **즉시 로딩**해서 실제 객체로 채워준다.
    
    **기본적으로는 inner join으로 동작**하고 left join이라고 명시하면 outer join이 된다.
    
    | 항목 | 설명 |
    | --- | --- |
    | 동작 방식 | SQL의 JOIN처럼 동작하며 Article과 Member를 **한 번에 조회**, 영속성 컨텍스트 1차 캐시에 저장되어 바로 활용될 수 있음 |
    | 대상 | @ManyToOne, @OneToMany 모두 가능 |
    | 장점 | N+1 완전 차단, 쿼리 한 번에 모든 데이터 조회 |
    | 단점 | 컬렉션에서 페이징 불가, 복잡한 조인 시 중복 문제 발생, LAZY 설정 사용 불가능, 이중 컬렉션 페치 불가 |
    
2. `@EntityGraph`
    
    Spring Data JPA에서 **연관 엔티티를 fetch join처럼 미리 불러오도록 지시(EAGER로 동작)**하는 선언적 방법이다. **left outer join이 사용되며** 페이징과 함께 사용 가능하다.
    
    | 항목 | 설명 |
    | --- | --- |
    | 동작 방식 | 내부적으로 **join fetch를 자동 생성** |
    | 대상 | @ManyToOne, @OneToMany |
    | 장점 | 페이징(Pageable) 가능, 코드 간결, 단건 + 컬렉션 가능 |
    | 단점 | 복잡한 조인에는 한계, **JPQL처럼 유연한 제어 어려움** |
    
3. `@BatchSize`
    
    * **지연 로딩이 발생할 때** ID를 모아 **IN 쿼리로 한 번에 조회 (추가 쿼리 1개)**
        
    * 전역 설정도 가능
        

Fetch Join을 이용해보려했으나 이중 페치 조인은 불가하여 `@EntityGrpah`를 사용하였다.

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1756731638737/93b2782a-8dea-4d45-ac0b-a1308b71053b.png align="center")

* `Cloth` → `ClothWithAttributes` → `Attribute`까지 한번에 조회
    
* 컬렉션 중첩이 아닌 **단건 + 컬렉션 구조**라서 가능
    

## 결과 (`@EntityGraph`적용 후) : 총 쿼리 수 **6개, 34m/s**

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1756731031931/72ff1e6b-047f-4bf2-bbf9-a85d6b3a83e7.png align="center")

## ✅ 성능 개선 수치

| 구분 | 쿼리 수 | 조회 시간 |
| --- | --- | --- |
| 기존(N+1 문제 발생) | **9개** | 169ms |
| EntityGraph 적용 | **6개** | 34ms |

* **쿼리 수 33% 감소**
    
* **조회 시간 약 5배, 80%개선 (169ms → 34ms)**
    
* 같은 데이터를 조회하면서도, **필요한 연관 관계를 미리 가져와 성능 최적화**
    

## 참고자료

[**N+1 문제 | Incheol's TECH BLOG**](https://incheol-jung.gitbook.io/docs/q-and-a/spring/n+1)​

[개발 N년차**JPA N+1 문제 해결 방법 및 실무 적용 팁 - 삽질중인 개발자**](https://programmer93.tistory.com/83#google_vignette)​

[평양냉면7**JPA N+1 문제 해결하기 (fetch join, entityGraph, batch size)**](https://yijoon009.tistory.com/entry/JPA-N1-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%ED%95%98%EA%B8%B0-fetch-join-entityGraph-batch-size)

[뱅어돔**JPA N+1 문제에 대하여 (BatchSize, EntityGraph)**](https://toquasimodox.tistory.com/8)​​

[https://tudamoa.tistory.com/13](https://tudamoa.tistory.com/13)