---
title: "컴퓨터 구성"
datePublished: Tue Sep 02 2025 15:00:00 GMT+0000 (Coordinated Universal Time)
cuid: cmgcfbpx4000102lb5ek2eieb
slug: 7lu07zoo7yswioq1royesq

---

## 1️⃣ 컴퓨터 기본 구성

* **필수 장치**
    
    * **CPU (중앙처리장치)**: 명령어 해석 및 실행
        
    * **메인 메모리(메모리)**: 작업에 필요한 프로그램과 데이터 저장, 바이트 단위 분할, 분할 공간마다 주소로 구분
        
* **주변 장치**
    
    * 입력 장치: 외부 데이터를 컴퓨터에 입력, 키보드, 마우스 등
        
    * 출력 장치: 컴퓨터에서 처리한 결과를 사용자가 원하는 형태로 출력, 모니터, 프린터 등
        
    * 보조 저장 장치: HDD, SSD, USB, CD/DVD 등 (메모리보다 느리지만 싸고 용량 크고 비휘발성)
        
* **구조**
    
    * HW구성
        
        * 메인보드: CPU, 메모리 등 다양한 부품 연결하는 판, 버스로 연결
            
    * **폰 노이만 구조**
        
        * CPU, 메모리, 입출력장치, 저장장치가 버스로 연결
            
        * 프로그램은 항상 **메모리로 불러와야 실행 가능**
            
        * 메모리가 유일한 작업 공간→메모리 관리 중요(ex.메모리 작으면 하나 작업하고 저장장치 옮김 반복 → 이동시간 증가→ 작업 속도 떨어짐)
            
* 프로그래밍
    
    * 프로그래밍 언어: 컴퓨터 프로그램을 만들 때 사용하는 언어
        
        * 기계어: 0,1의 이진수 언어
            
        * 어셈블리어: 기계어를 사람이 이해할 수 있는 문자 형태로 바꿈
            
        * 고급 언어: if for처럼 이해할 수 있는 단어로 만든 언어
            
    * 컴파일: 고급 언어 → 기계어 번역
        
        * 컴파일러: 컴파일 하는 프로그램
            
        * 컴파일러가 소스코드 번역하여 기계어로 이뤄진 실행파일 제작→작업시작
            
        * 인터프리터: 소스코드를 한문장씩 번역 후 바로 실행, 실행파일 없음, 반복작업을 하나로 합치기 어렵고 오류 파익 힘듦
            

---

## 2️⃣ CPU 구조

* **ALU (산술논리연산장치)**: 덧셈, 뺄셈, 논리연산 수행, 결과는 레지스터에 저장되거나 다음단계로 전달
    
* **제어 장치**: 명령어 해석 및 제어 신호 발생
    
* **레지스터** (작업에 필요한 데이터를 CPU내부에 임시 보관)
    
    * 휘발성, 속도 가장 빠름, 기억용량 가장 작음
        
    * DR (데이터 레지스터): 연산 데이터 임시 보관
        
    * AR (주소 레지스터): 데이터/명령어 위치 저장
        
    * PC (프로그램 카운터): 다음 실행할 명령어 주소 저장, 명령어 포인터
        
    * IR (명령어 레지스터): 현재 실행 중인 명령어 저장
        
    * MAR (메모리 주소 레지스터): 데이터를 메모리에서 가져오거나 보낼 때 주소 지정
        
    * MBR (메모리 버퍼 레지스터): 메모리에서 읽거나 쓸 데이터 임시 저장, MAR과 같이 동작
        
    * PSR (프로그램 상태 레지스터): 연산 결과 플래그 저장
        
* 인터럽트 라인
    
    * mode bit : CPU에서 실행되는 것이 OS인지 사용자 프로그램인지 구분
        
        * 0 : 커널 모드, OS가 CPU에서 실행 중인것→ 어떤 작업이든 가능
            
        * 1: 사용자 모드, 제한된 명령만 CPU에서 실행
            
* **버스 (Bus)**
    
    * 데이터 지나가는 통로
        
    * 시스템 버스(FSB,전면 버스): 메모리와 주변 장치 연결, 메인 보드 동작속도
        
    * CPU버스(BSB,후면 버스): CPU내부 다양한 장치 연결,CPU클록이 속도, FSB보다 빠름
        
        * 클록: 일정한 박자, 일정 간격 틱 = pulse/clock tick, 펄스를 만들면 이에 맞춰 컴퓨터 안 모든 구성 부품들이 작업 진행
            
        * Hz: CPU성능, 1초동안 몇번의 작업이 이뤄져 몇번의 펄스가 발생하였는가
            
    * 제어 버스: CPU가 메모리와 주변장치에 제어 신호 전달 (양방향)
        
    * 주소 버스: MAR과 연결, 주소 정보 전달 (단방향)
        
    * 데이터 버스: MBR과 연결, 데이터 전달 (양방향)
        
* **CPU 비트수**
    
    * 32bit CPU: 한 번에 최대 32bit 처리 가능
        
        * 레지스터크기, 버스 대역폭, 1워드 = 32bit
            
    * 워드: CPU가 한 번에 처리 가능한 데이터 최대 크기
        
    * 버스 대역폭 : 한번에 전달할 수 있는 데이터 최대 크기
        
    * 버스 대역폭 = 레지스터 크기=메모리에 한번에 저장할 수 있는 데이터 크기
        

---

## 3️⃣ 메모리 구조(주기억장치)

액세스 속도 높지만 프로그램 실행 중에만 사용될 수 있는 일시적 기억장치, 데이터 읽는 속도가 보조기억장치에 비해 상대적으로 빠름

* **RAM휘발성 메모리:** 전원 꺼지면 데이터 소멸, 속도 빠르고 읽기/쓰기 가능
    
    * DRAM: 저장된 0,1 데이터가 일정시간 되면 사라짐 → 일정시간마다 다시 재생
        
    * SRAM: 전원 공급 시 데이터 유지
        
    * SDRAM: 동기식 DRAM, CPU 클록 틱이 발생할 때마다 데이터 저장
        
* **비휘발성 메모리: 읽기만 가능**
    
    * 플래시 메모리 (USB, SD 카드): 전력없어도 데이터 보관
        
    * SSD : 비쌈,빠른 접근, 저전력, 내구성 높음
        
    * ROM
        
        * 마스크롬: 읽기 전용
            
        * PROM: 한 번만 기록 가능
            
        * EPROM: 지우고 다시 쓰기 가능
            
* **메모리 보호 기법**
    
    * 사용자 프로세스가 CPU차지하여 작업 진행→OS작업 중단→사용자 작업으로부터 메모리 보호
        
    * 경계 레지스터: 현재 진행 중인 작업의 시작 주소
        
    * 한계 레지스터: 현재 진행 중인 작업의 메모리 크기
        
* **부팅 과정**
    
    * 컴퓨터를 켰을 때 OS를 메모리에 올리는 과정
        

---

## 4️⃣ 성능 향상 기법

* **버퍼(Buffer)**: 속도 차 완화 (예: 스풀링 – 프린터 대기열)
    
* **캐시(Cache)**: CPU-메모리 속도 차 완화위한 데이터 임시 저장 장소
    
    * 버퍼 일종
        
    * CPU가 사용할 것으로 예상하는 데이터를 미리 가져다 놓음
        
    * 휘발성, 속도 빠름, 기억용량 작음
        
    * Cache Hit: 원하는 데이터 캐시에 존재
        
    * Cache Miss: 데이터가 없어 메모리 접근
        
    * 캐시 적중률: 캐시 히트 비율, 일반적으로 90%
        
    * L1 캐시(특수 캐시): CPU 레지스터에 연결, 명령/데이터 분리 가능 (가장 빠름)
        
    * L2 캐시(일반 캐시): 메모리와 연결, 모든 자료 갖고옴
        
* **쓰기 정책**
    
    * 즉시 쓰기: 캐시 갱신 시 메모리 즉시 반영 → 안전, 성능 느림
        
    * 지연 쓰기: 캐시에만 반영 후 일정 주기로 메모리 갱신 → 성능 빠름, 캐시와 메모리 불일치 가능
        
* **저장장치 계층 구조**
    
    * CPU와 가까울수록 빠르고 비싸며, 멀수록 느리지만 용량 큼
        
    * 레지스터 → 캐시 → 메모리 → 저장장치
        

---

## 5️⃣ 입출력 관리

* **폴링 방식**: CPU가 입출력 장치 상태를 계속 확인 (비효율적)
    
* **인터럽트 방식**: 입출력관리자가 CPU대신 입출력 장치 확인, CPU작업과 저장장치의 데이터 이동을 독립적으로 운영하여 시스템 효율 높임, 데이터 입출력 하는 동안 CPU는 다른 일 가능
    
    * 인터럽트: 입출력 관리자가 CPU에 보내는 완료 신호
        
    * 인터럽트 번호(IRQ): 어떤 장치의 작업이 끝났는지 CPU에게 알려주기 위한 번호
        
    * 인터럽트 벡터: 여러 입출력 작업을 한번에 처리하기 위해 여러 인터럽트를 하나의 배열로 만듦
        
    * HW인터럽트: IO디바이스에서 발생하는 인터럽트
        
    * SW인터럽트: 트랩, 프로세스가 시스템콜을 호출할 때 발동
        
* **직접 메모리 접근 (Direct Memory Access)**: 입출력 장치가 CPU 개입 없이 직접 메모리 접근
    
* **메모리 맵 입출력(Memory-Mapped I/O)**: 메모리 공간 일부를 입출력 전용으로 할당
    
* **사이클 훔치기(Cycle Stealing)**: DMA가 CPU와 동시에 메모리 접근 시, CPU가 잠시 양보
    

---

## 6️⃣ 메모리 관리

* 가상 메모리: 컴퓨터가 실제로 이용가능한 메모리 자원을 추상화하여 사용자에게 큰 메모리로 보이게 만드는 것, 가상 주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어있는 페이지 테이블로 관리, TLB사용
    
    * 실제 주소: 실제 메모리 상에 있는 주소
        
    * 가상 주소: 가상적으로 주어진 주소
        
    * 가상 주소는 메모리 관리 장치MMU의해 실제주소로 변환
        
    * TLB: 메모리와 CPU사이 주소 변환위한 캐시
        
* 스와핑: 가상 메모리에는 존재하지만 RAM에 없는 데이터일 경우 페이지 폴트 발생 → 메모리에서 지금 사용하지 않는 영역을 하드디스크로 옮겼다가 필요할 때 하드디스크의 일부분을 불러와 씀
    
    * 페이지 폴트: 프로세스의 주소공간에는 존재하지만 RAM에 없는 데이터에 접근했을 경우 발생
        
    * 페이지: 가상 메모리를 사용하는 최소 크기 단위
        
    * 프레임: 실제 메모리를 사용하는 최소 크기 단위
        
* 메모리 할당
    
    * 연속 할당: 메모리에 연속적으로 공간을 할당
        
        * 고정 분할 방식: 메모리를 미리 나누어 관리, 내부단편화 발생
            
        * 가변 분할 방식: 프로그램 크기에 맞게 동적으로 메모리 나눔, 외부 단편화 발생→ 해결 방법: 최초/최적/최악적합
            
            * 내부 단편화: 메모리를 나눈 크기보다 프로그램이 작아서 들어가지 못하는 공간이 발생
                
            * 외부 단편화: 메모리를 나눈 크기보다 프로그램이 커서 들어가지 못하는 공간이 발생
                
                * 최초 적합: 가장 처음 만나는 빈 메모리 공간에 프로세스 할당, 빠르다
                    
                * 최적 적합: 빈 메모리 공간의 크기와 프로세스 크기차이가 가장 적은 곳에 할당
                    
                * 최악 적합: 빈 메모리 공간의 크기와 프로세스 크기 차이가 가장 큰 곳에 할당
                    
            * 홀: 할당할 수 있는 비어있는 메모리 공간
                
    * 불연속 할당: 현대 OS쓰는 방법
        
        * 페이징: 동일한 크기의 페이지 단위로 나눠 메모리의 서로 다른 위치에 프로세스를 할당
            
        * 세그멘테이션:
            
            * 프로세스를 논리적 내용으로 나눠 메모리에 배치
                
            * 각 세그먼트의 크기는 동일하지 않음
                
            * 보호와 공유가 효율적
                
        * 페이지드 세그멘테이션: 페이징+세그멘테이션, 세그먼트를 페이징 기법으로 나누는 것, CPU안 세그먼트 테이블에서, 페이지 테이블에서 주소변환을 각각 해야하는 단점 존재